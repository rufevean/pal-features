<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Planets &amp; Moons: A Design Pattern in PAL | Features</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction
In software development the term design pattern is a useful appellation for a reoccurring issue that was dealt with haphazardly (often by boiler-plate machinations) but is now understood well enough to get a systematized solution and label.
Planet &amp; moons is a design pattern unique to PAL; no coding language has ever conceived of this feature let alone implemented it.
What they are
The planet is the main function which takes some input arguments and produces some outputs.">
<meta name="author" content="">
<link rel="canonical" href="/posts/planets/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Planets &amp; Moons: A Design Pattern in PAL" />
<meta property="og:description" content="Introduction
In software development the term design pattern is a useful appellation for a reoccurring issue that was dealt with haphazardly (often by boiler-plate machinations) but is now understood well enough to get a systematized solution and label.
Planet &amp; moons is a design pattern unique to PAL; no coding language has ever conceived of this feature let alone implemented it.
What they are
The planet is the main function which takes some input arguments and produces some outputs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/planets/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-27T17:41:21+05:30" />
<meta property="article:modified_time" content="2024-06-27T17:41:21+05:30" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Planets &amp; Moons: A Design Pattern in PAL"/>
<meta name="twitter:description" content="Introduction
In software development the term design pattern is a useful appellation for a reoccurring issue that was dealt with haphazardly (often by boiler-plate machinations) but is now understood well enough to get a systematized solution and label.
Planet &amp; moons is a design pattern unique to PAL; no coding language has ever conceived of this feature let alone implemented it.
What they are
The planet is the main function which takes some input arguments and produces some outputs."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/posts/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Planets \u0026 Moons: A Design Pattern in PAL",
      "item": "/posts/planets/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Planets \u0026 Moons: A Design Pattern in PAL",
  "name": "Planets \u0026 Moons: A Design Pattern in PAL",
  "description": "Introduction\nIn software development the term design pattern is a useful appellation for a reoccurring issue that was dealt with haphazardly (often by boiler-plate machinations) but is now understood well enough to get a systematized solution and label.\nPlanet \u0026amp; moons is a design pattern unique to PAL; no coding language has ever conceived of this feature let alone implemented it.\nWhat they are\nThe planet is the main function which takes some input arguments and produces some outputs.",
  "keywords": [
    
  ],
  "articleBody": "Introduction\nIn software development the term design pattern is a useful appellation for a reoccurring issue that was dealt with haphazardly (often by boiler-plate machinations) but is now understood well enough to get a systematized solution and label.\nPlanet \u0026 moons is a design pattern unique to PAL; no coding language has ever conceived of this feature let alone implemented it.\nWhat they are\nThe planet is the main function which takes some input arguments and produces some outputs. When the input arguments need to be managed (often to increase invocation clarity) or when the function needs to be modified, then moons are used. Whenever a planet is created, all its moons are defined with it at the same time.\nThe moons are specialized local functions, which act as either adverbs, or as adjectives. When used as adjectives, they qualify the inputs to their planet; they group, categorize, and describe their planet function’s argument list. Moons only become visible when their planet is invoked, since they are proximity based.\nThe reason for the specific terms ‘planet’ and ‘moons’ are:\nMoons are local to the planet they orbit; their names only come into scope through proximity of the planet they are nearest to. Outside of the orbit of their planet, moons are invisible.\nThe planet is big because moons orbit it, not the other way around; it is the influencer, and dictates the meanings of the local moons around it.\nMoons are small because there can be many of them, and they all get their prescribed meaning from the planet they orbit.\nThe scope of the moons lie in “the shadow’’ of their planet; if their planet function isn’t nearby, the moons become invisible to the current scope. If a moon so happens to have the same name as some other entity in a wider contextual scope, then its locally (planetary proximity dictated) prescribed meaning takes precedence, and over-rides the outer scope meaning.\nWhy we need them\nTo aid comprehension, we need to appreciate the need that planet \u0026 moons fill. This is best achieved with a concrete example.\nImagine a function called rotate, that takes 8 arguments for its input, and outputs a tuple of 3 values, and all 8 inputs are of the same data type; which is the default numeric Real. Invoking would look like this in source-code:\nx, y, z ← rotate(x, y, z, X, Y, Z, theta, phi)\nWe will now zoom in on the actual function call; no longer showing its output being captured by the assignment statement. So now we simply have:\nrotate(x, y, z, X, Y, Z, theta, phi)\nExcluding the fact it outputs a tuple, this could be done in almost any coding language.\nThe question is: how far can we improve our code to explicate the meaning (purpose and intent) of this function invocation?\nWe can use white space to meaningfully segregate the various function arguments:\nrotate(x, y, z, X,Y,Z, theta, phi)\nwhich helps a bit.\nMore significantly we can replace the tacit arguments with meaningful names. Something like:\nrotate(x, y, z, X_origin, Y_origin, Z_origin, theta, phi)\nIn any other language we would have now reached the end of the road; since no more improvements to readability can be done.\nBut not for us; with PAL we can employ source–hinting to take us further, like a Sherpa guide, up the mountain of clarity. We can insert explanatory words (in this case, round and by) to give us:\nrotate(x, y, z, ‹round› X_origin, Y_origin, Z_origin, ‹by› theta, phi)\nIn fact, we can now increase clarity by reverting back to using the shorter tacit argument names again:\nrotate(x, y, z, ‹round› X, Y, Z, ‹by› theta, phi)\nWe are not done yet, because PAL also provides us with an extended (and extensible) glyph range for symbol names, so we can replace the ‘‘theta’’ and ‘‘phi’’ with shorter names while boosting clarity. Heck while we are at it, we can also come up with better names for the ‘X’, ‘Y’, and ‘Z’ too:\nrotate(x, y, z, ‹round› χ, ƴ, ȥ, ‹by› θ, ϕ)\nLastly, since we are permitted relaxed–functions, we can ditch the function parenthesis, since they aren’t really earning their keep. Which brings us to:\nrotate x, y, z, ‹round› χ, ƴ, ȥ, ‹by› θ, ϕ\nWe could go further and omit all those comas too, but we will stop here.\nSo in the journey of elucidating our use of this rotate function, it would seem no more can be done to enhance readability.\nBut we have not reached the summit; there remain some arbitrary limitations to what we have achieved:\nWhat if we want to be able to omit more than one argument by being able to rely on some default values being provided to this function? (Remember that it was stated earlier that ALL the input arguments to this function are of the SAME data type; this would normally mean that only the last function argument can be specified to be an optional parameter.)\nWhy not be able to change the invocation order of the arguments? For example, maybe it would look nicer to specify the rotation angles: (θ ϕ) prior to specifying the pivot coordinate: (χ ƴ ȥ).\nThe only way forward now, is through use of the planet \u0026 moons facility.\nHow to make them\nWe will now define or extend our function to be a planet, with associated moon functions.\nThis is easily done, like so:\n▪ rotate (x y z) round (χ ƴ ȥ) by (θ ϕ) ───‣ (x y z) ◌ ◌ ◌\nIn the above definition, the planet function is rotate, and it has 2 moons: by and around; which both gather and label the parameters. (The dotted–circle glyph represents folded code from the IDE editor.)\nThis now gifts us a choice of calling our rotate function with two alternative orderings of its arguments.\nWe can still invoke the way we did before, with the rotation angles supplied as the last arguments:\nrotate x, y, z round χ, ƴ, ȥ by θ, ϕ\nOr we can now choose to invoke by specifying the rotation angles ahead of the pivot coordinate point:\nrotate x, y, z by θ, ϕ round χ, ƴ, ȥ\nWe can still proceed further by adding another moon to gather the arguments that we were giving directly to the planet itself, by minting the signature this way:\n▪ rotate point(x y z) round (χ ƴ ȥ) by (θ ϕ) ───‣ (x y z) ◌ ◌ ◌\nSo we can now re-order THREE groups of arguments instead of simply two. For example, we now have the freedom to invoke it this way:\nrotate by θ, ϕ point x, y, z round χ, ƴ, ȥ\nwith the rotation angles being specified first, followed by the point we want to rotate, with the pivot point being specified last.\nOr we can invoke this way:\nrotate by θ, ϕ round χ, ƴ, ȥ point x, y, z\nWith the coordinate point we intend to rotate coming dead last in the argument list. Etc.\nNot that all of these options are equally good, but the point is that we DO have a choice!\nNow, how about being able to use our rotate function with omitted arguments? This is easily achieved by specifying which arguments can be omitted. We can do this on a moon by moon basis:\nTo Be Continued …\n",
  "wordCount" : "1234",
  "inLanguage": "en",
  "datePublished": "2024-06-27T17:41:21+05:30",
  "dateModified": "2024-06-27T17:41:21+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/planets/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Features",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Features (Alt + H)">Features</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://paltek.vercel.app" title="Home">
                    <span>Home</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Planets &amp; Moons: A Design Pattern in PAL
    </h1>
    <div class="post-meta"><span title='2024-06-27 17:41:21 +0530 IST'>June 27, 2024</span>

</div>
  </header> 
  <div class="post-content"><p>Introduction</p>
<p>In software development the term design pattern is a useful appellation for a reoccurring issue that was dealt with haphazardly (often by boiler-plate machinations) but is now understood well enough to get a systematized solution and label.</p>
<p>Planet &amp; moons is a design pattern unique to PAL; no coding language has ever conceived of this feature let alone implemented it.</p>
<p>What they are</p>
<p>The planet is the main function which takes some input arguments and produces some outputs.  When the input arguments need to be managed (often to increase invocation clarity) or when the function needs to be modified, then moons are used.
Whenever a planet is created, all its moons are defined with it at the same time.</p>
<p>The moons are specialized local functions, which act as either adverbs, or as adjectives.  When used as adjectives, they qualify the inputs to their planet; they group, categorize, and describe their planet function’s argument list.  Moons only become visible when their planet is invoked, since they are proximity based.</p>
<p>The reason for the specific terms ‘planet’ and ‘moons’ are:</p>
<p>Moons are local to the planet they orbit; their names only come into scope through proximity of the planet they are nearest to.  Outside of the orbit of their planet, moons are invisible.</p>
<p>The planet is big because moons orbit it, not the other way around; it is the influencer, and dictates the meanings of the local moons around it.</p>
<p>Moons are small because there can be many of them, and they all get their prescribed meaning from the planet they orbit.</p>
<p>The scope of the moons lie in “the shadow’’ of their planet; if their planet function isn&rsquo;t nearby, the moons become invisible to the current scope.  If a moon so happens to have the same name as some other entity in a wider contextual scope, then its locally (planetary proximity dictated) prescribed meaning takes precedence, and over-rides the outer scope meaning.</p>
<p>Why we need them</p>
<p>To aid comprehension, we need to appreciate the need that planet &amp; moons fill.  This is best achieved with a concrete example.</p>
<p>Imagine a function called rotate, that takes 8 arguments for its input, and outputs a tuple of 3 values, and all 8 inputs are of the same data type; which is the default numeric Real.   Invoking would look like this in source-code:</p>
<p>x, y, z  ←  rotate(x, y, z, X, Y, Z, theta, phi)</p>
<p>We will now zoom in on the actual function call; no longer showing its output being captured by the assignment statement.  So now we simply have:</p>
<p>rotate(x, y, z, X, Y, Z, theta, phi)</p>
<p>Excluding the fact it outputs a tuple, this could be done in almost any coding language.</p>
<p>The question is: how far can we improve our code to explicate the meaning (purpose and intent) of this function invocation?</p>
<p>We can use white space to meaningfully segregate the various function arguments:</p>
<p>rotate(x, y, z,  X,Y,Z,  theta, phi)</p>
<p>which helps a bit.</p>
<p>More significantly we can replace the tacit arguments with meaningful names.  Something like:</p>
<p>rotate(x, y, z,  X_origin, Y_origin, Z_origin,  theta, phi)</p>
<p>In any other language we would have now reached the end of the road; since no more improvements to readability can be done.</p>
<p>But not for us; with PAL we can employ source–hinting to take us further, like a Sherpa guide, up the mountain of clarity.  We can insert explanatory words (in this case, round and by) to give us:</p>
<p>rotate(x, y, z,  ‹round› X_origin, Y_origin, Z_origin,  ‹by› theta, phi)</p>
<p>In fact, we can now increase clarity by reverting back to using the shorter tacit argument names again:</p>
<p>rotate(x, y, z,  ‹round› X, Y, Z,  ‹by› theta, phi)</p>
<p>We are not done yet, because PAL also provides us with an extended (and extensible) glyph range for symbol names, so we can replace the ‘‘theta’’ and ‘‘phi’’ with shorter names while boosting clarity.
Heck while we are at it, we can also come up with better names for the ‘X’, ‘Y’, and ‘Z’ too:</p>
<p>rotate(x, y, z,  ‹round› χ, ƴ, ȥ,  ‹by› θ, ϕ)</p>
<p>Lastly, since we are permitted relaxed–functions, we can ditch the function parenthesis, since they aren&rsquo;t really earning their keep.  Which brings us to:</p>
<p>rotate  x, y, z,  ‹round› χ, ƴ, ȥ,  ‹by› θ, ϕ</p>
<p>We could go further and omit all those comas too, but we will stop here.</p>
<p>So in the journey of elucidating our use of this rotate function, it would seem no more can be done to enhance readability.</p>
<p>But we have not reached the summit; there remain some arbitrary limitations to what we have achieved:</p>
<p>What if we want to be able to omit more than one argument by being able to rely on some default values being provided to this function?
(Remember that it was stated earlier that ALL the input arguments to this function are of the SAME data type; this would normally mean that only the last function argument can be specified to be an optional parameter.)</p>
<p>Why not be able to change the invocation order of the arguments?
For example, maybe it would look nicer to specify the rotation angles: (θ ϕ) prior to specifying the pivot coordinate: (χ ƴ ȥ).</p>
<p>The only way forward now, is through use of the planet &amp; moons facility.</p>
<p>How to make them</p>
<p>We will now define or extend our function to be a planet, with associated moon functions.</p>
<p>This is easily done, like so:</p>
<p>▪ rotate (x  y  z)   round (χ  ƴ  ȥ)   by (θ  ϕ)   ───‣   (x  y  z)
◌
◌
◌</p>
<p>In the above definition, the planet function is rotate, and it has 2 moons: by and around; which both gather and label the parameters.  (The dotted–circle glyph represents folded code from the IDE editor.)</p>
<p>This now gifts us a choice of calling our rotate function with two alternative orderings of its arguments.</p>
<p>We can still invoke the way we did before, with the rotation angles supplied as the last arguments:</p>
<p>rotate  x, y, z   round χ, ƴ, ȥ   by θ, ϕ</p>
<p>Or we can now choose to invoke by specifying the rotation angles ahead of the pivot coordinate point:</p>
<p>rotate  x, y, z   by θ, ϕ   round χ, ƴ, ȥ</p>
<p>We can still proceed further by adding another moon to gather the arguments that we were giving directly to the planet itself, by minting the signature this way:</p>
<p>▪ rotate  point(x  y  z)   round (χ  ƴ  ȥ)   by (θ  ϕ)   ───‣  (x  y  z)
◌
◌
◌</p>
<p>So we can now re-order THREE groups of arguments instead of simply two.
For example, we now have the freedom to invoke it this way:</p>
<p>rotate  by θ, ϕ   point x, y, z   round χ, ƴ, ȥ</p>
<p>with the rotation angles being specified first, followed by the point we want to rotate, with the pivot point being specified last.</p>
<p>Or we can invoke this way:</p>
<p>rotate  by θ, ϕ   round χ, ƴ, ȥ   point x, y, z</p>
<p>With the coordinate point we intend to rotate coming dead last in the argument list.  Etc.</p>
<p>Not that all of these options are equally good, but the point is that we DO have a choice!</p>
<p>Now, how about being able to use our rotate function with omitted arguments?
This is easily achieved by specifying which arguments can be omitted.  We can do this on a moon by moon basis:</p>
<p>To Be Continued …</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="/">Features</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
